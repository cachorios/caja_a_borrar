<?php

namespace Caja\SistemaCajaBundle\Entity;

use Doctrine\ORM\EntityRepository;
use Caja\SistemaCajaBundle\Entity\LoteDetalle;
/**
 * LoteRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class LoteRepository extends EntityRepository
{
    /**
     * A partir de un numero de comprobante, se recuperan los comprobantes
     *pertenecientes al lote correspondiente, que no esten anulados
     * @param $codigo_barra
     * @return mixed
     */
    public function getLote($apertura_id, $codigo_barra)
    {
        $em = $this->getEntityManager();
        $q = $em->createQuery("
              SELECT ld
              FROM
                  SistemaCajaBundle:LoteDetalle ld JOIN ld.lote l
              WHERE
                  ld.codigo_barra = :codigo_barra
                  and l.apertura = :apertura_id
                  and ld.anulado = 0
              ");
        $q->setParameter('codigo_barra', $codigo_barra);
        $q->setParameter('apertura_id', $apertura_id);

        try {
            $res = $q->getSingleResult();
            return $res->getLote();
        } catch (\Doctrine\Orm\NoResultException $e) {
            //No trajo resultados:
            return null;
        }  catch (\Doctrine\Orm\NonUniqueResultException $e) {
            //Si devolvio una excepcion es porque trajo mas de un resultado,
            // o sea es un error grave haber cobrado mas de una vez un comprobante
            return null;
        }
    }

    /**
     * Consulta de cantidad de pagos de un lote determinado
     * @param $lote_id
     * @return int
     */
    public function getConsultaCantidadPagos($lote_id){
        $em = $this->getEntityManager();

        $consulta_cantidad_pagos = $em->createQuery("
            SELECT COUNT(p.tipo_pago)
            FROM SistemaCajaBundle:LotePago p
            WHERE p.lote = :lote_id ")
            ->setParameter("lote_id", $lote_id);
        $cantidad_pagos = $consulta_cantidad_pagos->getSingleResult();
        $cantidad_pagos = $cantidad_pagos[1];

        return $cantidad_pagos;
    }

    /**
     * Consulta el tipo de pago cuando el lote se pago en un solo pago
     * @param $lote_id
     * @return int
     */
    public function getConsultaTipoPago($lote_id){
        $em = $this->getEntityManager();

        $consulta_tipo_pago= $em->createQuery("
                SELECT tp.divisible
                FROM SistemaCajaBundle:LotePago p JOIN p.tipo_pago tp
                WHERE p.lote = :lote_id ")
            ->setParameter("lote_id", $lote_id);

        $consulta_tipo_pago->setMaxResults(1);
        $resultado = $consulta_tipo_pago->getSingleResult();
        $tipo_pago = $resultado['divisible'];

        return $tipo_pago;
    }

    /**
     * Consulta el monto pagado en efectivo de un lote
     * @param $lote_id
     * @return $float
     */
    public function getMontoEfectivo($lote_id){
        $em = $this->getEntityManager();

        $consulta_efectivo = $em->createQuery("SELECT sum(p.importe)
                FROM SistemaCajaBundle:LotePago p
                JOIN p.tipo_pago tp
                WHERE tp.descripcion = 'Efectivo'
                 and p.lote = :lote_id ")
            ->setParameter("lote_id", $lote_id);
        $consulta_efectivo->setMaxResults(1);
        $efectivo = $consulta_efectivo->getSingleResult();
        $efectivo = $efectivo[1];

        return $efectivo;
    }


    /**
     * Anula un registro de lote de pago
     * @param $comprobantes
     * @param $lote_id
     * @return $integer
     */
    public function anularLoteDetallePorComprobantes($comprobantes, $lote_id){
        $em = $this->getEntityManager();

        $lotesdetalles      = $em->createQuery("update SistemaCajaBundle:LoteDetalle ld set ld.anulado = true where ld.lote = :lote_id and ld.codigo_barra in (:comprobantes)")
            ->setParameter("lote_id", $lote_id)->setParameter("comprobantes", $comprobantes);
        $lotes_actualizados = $lotesdetalles->execute();

        return $lotes_actualizados;
    }


    public function getMontoComprobantesSeleccionados($comprobantes){
        $em = $this->getEntityManager();

        $consulta_monto = $em->createQuery("SELECT sum(ld.importe)
                FROM SistemaCajaBundle:LoteDetalle ld
                WHERE ld.codigo_barra in (:comprobantes)")
            ->setParameter("comprobantes", $comprobantes);
        $consulta_monto->setMaxResults(1);
        $monto_a_anular = $consulta_monto->getSingleResult();
        $monto_a_anular = $monto_a_anular[1];

        return $monto_a_anular;
    }


    /**
     * Verifica si el lote se puede anular parcialmente
     * @param
     * @return $boolean
     */
    public function verificaAnulacionParcial($lote, $comprobantes){
        $em = $this->getEntityManager();

        $puede_anular_parcialmente = "OK";
        $lote_id = $lote->getId();
        $total_comprobantes_lote = $lote->getDetalle()->count();
        $total_comprobantes_seleccionados = count($comprobantes);

        $cantidad_pagos = $this->getConsultaCantidadPagos($lote_id); //Pregunto cuantos tipos de pagos se hicieron en ese lote:

        if ($cantidad_pagos == 1) {
            // si es un solo pago se puede anular el comprobante, independientemente del tipo de pago
            $tipo_pago_divisible = $this->getConsultaTipoPago($lote_id); //recupero el tipo de pago

            //el tipo de pago en el registro negativo sera el obtenido en la linea anterior ($tipo_pago_divisible). Si el pago no fue en efectivo, solo se puede anular el lote completo:
            if (($tipo_pago_divisible != 1) && (count($comprobantes) < $total_comprobantes_lote)) {
                $puede_anular_parcialmente ="'El lote no fue abonado en efectivo, solo se puede anular de manera total.";
            }
        } else { //Se pago con mas un tipo de pago, entonces:
            // se anula todo el lote, o se anula hasta donde le alcance el efectivo
            if ($total_comprobantes_seleccionados < $total_comprobantes_lote ) { //SE ANULA PARTE DEL LOTE: se anula hasta donde le alcance el efectivo:
                //Comparo el monto abonado en efectivo para ese lote con el monto del comprobante/s a anular
                $efectivo = $this->getMontoEfectivo($lote_id);

                //Calculo el monto de los comprobantes seleccionados para anular:
                $monto_a_anular = $this->getMontoComprobantesSeleccionados($comprobantes);

                //Se verifica que se hayan seleccionado todos los comprobantes que componen el lote:
                if ($monto_a_anular > $efectivo) {
                   $puede_anular_parcialmente = 'El monto de los comprobantes seleccionados ($' . $monto_a_anular . ') es mayor al importe abonado en efectivo ($' . $efectivo . ')';
                }
            }
        }

        return $puede_anular_parcialmente;

    }

    /**
     *
     */
    public function anularComprobantesLote($lote, $comprobantes, $user){
        $em = $this->getEntityManager();
        $total_comprobantes_lote = $lote->getDetalle()->count();
        $total_comprobantes_seleccionados = count($comprobantes);

        $em->getConnection()->beginTransaction(); // suspende la consignación automática
        try {
            //Se procede a anular el o los lotes detalles:
            $lotes_actualizados = $this->anularLoteDetallePorComprobantes($comprobantes, $lote->getId());

            // Verifico que haya anulado la totalidad de los comprobantes ingresados:
            if ($lotes_actualizados != count($comprobantes)) {
                throw new \Exception('No se pudieron anular los comprobantes seleccionados.');
            }

            $tipo_pago = $em->getRepository('SistemaCajaBundle:TipoPago')->getTipoPagoDivisible(1); //Recupero el tipo de pago:
            if (!$tipo_pago) {
                throw new \Exception('No se pudo recuperar el tipo de pago.');
            }

            //FALTA PREGUNTAR SI LA ANULACION ES TOTAL O NO PARA MARCAR LOS LOTE DE PAGO
            $comprobantes = $em->getRepository('SistemaCajaBundle:LoteDetalle')->findBy(array('codigo_barra' => $comprobantes));
            if ($total_comprobantes_seleccionados < $total_comprobantes_lote ) { //SE ANULA PARTE DEL LOTE:
                //Por cada comprobante anulado, se mete un registro "negativo" en el lote de pago

                foreach ($comprobantes as $comprobante) {
                    $em->getRepository('SistemaCajaBundle:LotePago')->anularLotePagoPorComprobantes($lote, $tipo_pago, -$comprobante->getImporte());
                }
            }else{ //se anula lote completo
                $lotePagos = $em->getRepository('SistemaCajaBundle:LotePago')->findBy(array('lote' => $lote->getId()));

                foreach ($lotePagos as $lp) {
                    $em->getRepository('SistemaCajaBundle:LotePago')->anularLotePagoPorComprobantes($lote, $lp->getTipoPago(), -$lp->getImporte());
                }
            }

            //genero cabecera lote anulación
            $loteAnulacion = new LoteAnulacion();
            $loteAnulacion->setFecha(new \DateTime());
            $loteAnulacion->setUsuario($user);
            ///////////////////////////ANULACION////////////////////////////

            $em->persist($loteAnulacion);

            foreach ($comprobantes as $comprobante) {
                // consulta por un lote detalle que coincide en el código barra
                //$detalle =  $em->getRepository('SistemaCajaBundle:LoteDetalle')->findOneBy(array('codigoBarra'  => $comprobante));

                //genero registro de lote detalle anulación
                $registro_lote_anulacion_detalle = new LoteAnulacionDetalle();
                $registro_lote_anulacion_detalle->setLote($loteAnulacion);
                $registro_lote_anulacion_detalle->setDetalle($comprobante);
                $em->persist($registro_lote_anulacion_detalle);
            }

            $em->flush();
            $em->getConnection()->commit();

            /**/
            /*Generación*/

            /**/


        } catch (Exception $e) {
            $em->getConnection()->rollback();
            $em->close();
            throw new \Exception($e->getMessage());
            //throw $e;
            //$this->get('session')->getFlashBag()->add('error', 'Hubo un fallo al guardar los datos: '.$e);

        }
    }



}